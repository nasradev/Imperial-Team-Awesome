% % % Auto-generated by cameraCalibrator app on 14-Nov-2016
% % %-------------------------------------------------------
% % 
% % 
% % % Define images to process
% % imageFileNames = {'C:\Dev\Matlabbing\Scripts\Image2.png',...
% %     'C:\Dev\Matlabbing\Scripts\Image4.png',...
% %     'C:\Dev\Matlabbing\Scripts\Image5.png',...
% %     'C:\Dev\Matlabbing\Scripts\Image6.png',...
% %     'C:\Dev\Matlabbing\Scripts\Image7.png',...
% %     'C:\Dev\Matlabbing\Scripts\Image8.png',...
% %     'C:\Dev\Matlabbing\Scripts\Image9.png',...
% %     'C:\Dev\Matlabbing\Scripts\Image10.png',...
% %     'C:\Dev\Matlabbing\Scripts\Image11.png',...
% %     'C:\Dev\Matlabbing\Scripts\Image12.png',...
% %     'C:\Dev\Matlabbing\Scripts\Image14.png',...
% %     'C:\Dev\Matlabbing\Scripts\Image15.png',...
% %     'C:\Dev\Matlabbing\Scripts\Image18.png',...
% %     'C:\Dev\Matlabbing\Scripts\Image19.png',...
% %     };
% % 
% % % Detect checkerboards in images
% % [imagePoints, boardSize, imagesUsed] = detectCheckerboardPoints(imageFileNames);
% % imageFileNames = imageFileNames(imagesUsed);
% % 
% % % Generate world coordinates of the corners of the squares
% % squareSize = 5;  % in units of 'mm'
% % worldPoints = generateCheckerboardPoints(boardSize, squareSize);
% % 
% % % Calibrate the camera
% % [cameraParams, imagesUsed, estimationErrors] = estimateCameraParameters(imagePoints, worldPoints, ...
% %     'EstimateSkew', false, 'EstimateTangentialDistortion', false, ...
% %     'NumRadialDistortionCoefficients', 2, 'WorldUnits', 'mm', ...
% %     'InitialIntrinsicMatrix', [], 'InitialRadialDistortion', []);
% % 
% % % View reprojection errors
% % h1=figure; showReprojectionErrors(cameraParams, 'BarGraph');
% % 
% % % Visualize pattern locations
% % h2=figure; showExtrinsics(cameraParams, 'CameraCentric');
% % 
% % % Display parameter estimation errors
% % displayErrors(estimationErrors, cameraParams);
% % 
% % % For example, you can use the calibration data to remove effects of lens distortion.
% % originalImage = imread(imageFileNames{1});
% % undistortedImage = undistortImage(originalImage, cameraParams);
% % 
% % % See additional examples of how to use the calibration data.  At the prompt type:
% % % showdemo('MeasuringPlanarObjectsExample')
% % % showdemo('StructureFromMotionExample')


% Reset everything, and start capturing
imaqreset
% The format need to fit to your camera. The easiest way to check this is  
% to check out the Image Aquisition app
obj = videoinput('winvideo',1,'MJPG_640x480');
yellow = uint8([255 255 0]);
red = uint8([255 0 0]);
%K = [0.6107561, 0, 3.332880, 0; 0, 0.6075771, 2.165117, 0; 0, 0, 1, 0; 0, 0, 0, 0];

try   
    %Initialize various parameters, and load in the template data
    set(obj,'framesperTrigger',10,'TriggerRepeat',Inf);
    start(obj);

    % h is a handle to the canvas
    h = imshow(zeros(480,640));
    hold on;

    figure(1);
    
    prevGroundX = 0;
    prevGroundY = 0;
    while islogging(obj);              
        data = getdata(obj,1);
        flushdata(obj);
        [imagePoints, boardSize] = detectCheckerboardPoints(data);
        
        if length(imagePoints) > 6
            
            firstColour = yellow;
            secondColour = red;
            %insert a black rectangle in order to hide the prev checkerboard
            %so we can find the next one
            shapeInserter = vision.ShapeInserter('Fill', true,'Opacity',1);
            padding = 10;
            rectW = min(imagePoints(:,1)) -  max(imagePoints(:,1)) + padding;
            rectL = min(imagePoints(:,2)) -  max(imagePoints(:,2)) + padding;
            startX = min(imagePoints(:,1));
            startY = min(imagePoints(:,2));
            rectangle = int32([startX startY abs(rectW) abs(rectL)]);

            %dataTemp = step(shapeInserter, data, rectangle);
            data = step(shapeInserter, data, rectangle);
            %[imagePoints2, boardSize2] = detectCheckerboardPoints(dataTemp);
            [imagePoints2, boardSize2] = detectCheckerboardPoints(data);
        
            %see if we found a second checkerboard
            if length(imagePoints2) > 6
                
%               if sqrt(power((startX - prevGroundX),2) + ...
%                       power((startY - prevGroundY),2)) ...
%                  > sqrt(power((min(imagePoints2(:,1)) - prevGroundX),2) + ...
%                       power((min(imagePoints2(:,2)) - prevGroundY),2))
              if sqrt(power((startX - prevGroundX),2) + ...
                      power((startY - prevGroundY),2)) ...
                 < sqrt(power((min(imagePoints2(:,1)) - prevGroundX),2) + ...
                      power((min(imagePoints2(:,2)) - prevGroundY),2))
                 
                 prevGroundX = startX;
                 prevGroundY = startY;
              else
                  prevGroundX = min(imagePoints2(:,1));
                  prevGroundY = min(imagePoints2(:,2));
                  firstColour = red;
                  secondColour = yellow;
              end
              %insert the circles outlining the second checkerboard
              shapeInserter = vision.ShapeInserter('Shape','Circles','BorderColor','Custom',...
    'CustomBorderColor',secondColour);
              %for j= 1:length(imagePoints2(:,1))-1
              for j= 1:1
               circle = int32([imagePoints2(j,1) imagePoints2(j,2) 2; 0 0 0]);
               data = step(shapeInserter, data, circle);
              end
                       %Finally, calculate distance from second pattern:
                       squareSize = 5.4; % in millimeters
                       worldPoints2 = generateCheckerboardPoints(boardSize2, squareSize);
                       [R, t] = extrinsics(imagePoints2, worldPoints2, cameraParams);
                       % Convert to world coordinates.
                       cboard2_world  = pointsToWorld(cameraParams, R, t, imagePoints2(1,:));

                       % Add the 1 z-coordinate.
                       cboard2_world = [cboard2_world 0];

                       % Compute the distance to the camera.   
                       distanceToCamera = norm(cboard2_world + t);
                       position = [350 50];
                       t = strcat('Distance mm: ', num2str(distanceToCamera));
                       text = [t];
                       data = insertText(data, position, text, 'FontSize',18,'BoxColor',...
                        secondColour,'BoxOpacity',0.4,'TextColor','white');

            end

              
            
            %insert the circles outlining the first checkerboard
            shapeInserter = vision.ShapeInserter('Shape','Circles','BorderColor','Custom',...
    'CustomBorderColor',firstColour);
            %for j= 1:length(imagePoints(:,1))-1
            for j= 1:1
               circle = int32([imagePoints(j,1) imagePoints(j,2) 2; 0 0 0]);
               data = step(shapeInserter, data, circle);
            end
            
           %Finally, calculate distance from first pattern:
           squareSize = 5.4; % in millimeters
           worldPoints = generateCheckerboardPoints(boardSize, squareSize);
           [R, t] = extrinsics(imagePoints, worldPoints, cameraParams);
           % Convert to world coordinates.
           cboard1_world  = pointsToWorld(cameraParams, R, t, imagePoints(1,:));

           % Compute the distance to the camera.   
           distanceToCamera = norm(t);
           position = [50 50];
           txt = strcat('Distance mm: ', num2str(distanceToCamera));
           text = [txt];
           data = insertText(data, position, text, 'FontSize',18,'BoxColor',...
            firstColour,'BoxOpacity',0.4,'TextColor','white');

        end


        %% This is what paints on the canvas
        %set(h,'Cdata',I);
        set(h,'Cdata',data);
        drawnow;
    end

catch err
    % This attempts to take care of things when the figure is closed
    stop(obj);
    imaqreset
    disp('Cleaned up')
    rethrow(err);
end    